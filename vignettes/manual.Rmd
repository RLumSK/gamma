---
title: "Manual"
author: "N. Frerebeau"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    fig_caption: yes
    toc: true
header-includes:
   - \usepackage{amsmath}
   - \usepackage{amssymb}
bibliography: bibliography.bib
vignette: >
  %\VignetteIndexEntry{manual}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(gamma)
library(magrittr)
```

## Spectrum inspection
### Import a CNF file
```{r import, fig.width=7, fig.height=5, fig.alipeaks_pgn="center"}
# Import a CNF file
cnf_test <- system.file("extdata/test.cnf", package = "gamma")
spc_cnf <- read(cnf_test)
spc_cnf

# Import a TKA file
tka_test <- system.file("extdata/test.tka", package = "gamma")
spc_tka <- read(tka_test)
spc_tka

# Import all file
files_test <- system.file("extdata", package = "gamma")
spc <- read(files_test)
spc

# Plot spectra
plot(spc, xaxis = "chanel", yaxis = "rate", facet = TRUE) +
  ggplot2::labs(x = "Chanel", y = "Count rate [1/s]") +
  ggplot2::theme_bw()
```

### Estimate and remove background
Algorithme SNIP [@ryan1988; @morhac1997; @morhac2008]

```{r baseline-estimate, fig.width=7, fig.height=5, fig.align="center"}
# Estimate baseline
baseline <- estimateBaseline(spc_cnf, method = "SNIP")

# Plot spectrum + baseline
plot(spc_cnf, baseline) +
  ggplot2::labs(x = "Energy [keV]", y = "Count") +
  ggplot2::theme_bw()
```

```{r baseline-remove, fig.width=7, fig.height=5, fig.align="center"}
# Substract previously estimated baseline
spc_clean1 <- spc_cnf - baseline
# Or, you can just remove baseline from spectrum
spc_clean2 <- removeBaseline(spc_cnf, method = "SNIP")

identical(spc_clean1, spc_clean2)

# Plot spectra
plot(spc_clean1) +
  ggplot2::labs(x = "Energy [keV]", y = "Count") +
  ggplot2::theme_bw()
```

### Automatic peak detection
On peut tenter de détecter automatiquement les pics présents dans le spectre.
Un pic est identifié comme tel s'il y a changement de signe de la courbe dans une fenêtre donnée et si la valeur est supérieure a *n* fois le rapport signal sur bruit.

Le vrai problème reside dans le choix de la fenêtre pour la recherche de pics.
Si `span = NULL` la demi-fenêtre de recherche est fixée à 5% du nombre de canaux.

```{r peak-detection, fig.width=7, fig.height=5, fig.align="center", fig.show="hold"}
# Detect peaks
peak_index <- findPeaks(spc_clean1, SNR = 2, span = 20)

plot(peak_index, xaxis = "chanel") +
  ggplot2::labs(x = "Chanel", y = "Count") +
  ggplot2::theme_bw()
```

### Peak fitting
Comme le spectre est bruité, il peut y avoir un léger décalage entre la position du pic identifié automatiquement et la valeur attendue. Pour améliorer ça, on ajuste des gaussiennes aux positions souhaitées et on en récupère les paramètres. La position du pic retenue est alors la valeur du spectre la plus proche de la moyenne de la gaussienne correspondante.

On peut ajuster des gaussiennes directement à partir des résultats de l'étape précédente (détection automatique) ou spécifier les positions de départ.

Si les pics sont trop rapprochés ou le signal trop bruité, la première solution peut ne pas aboutir (problème de convergence lors de l'ajustement des gaussiennes). Dans la mesure où on est interessé par seulement trois pics (238, 1461, 2614.5 keV), la seconde approche produit de meilleurs résultats (et réduit le temps de calcul).

Dans tous les cas, mieux vaut vérifier visuellement les résultats après.

```{r peak-fitting, fig.width=7, fig.height=5, fig.align="center", fig.show="hold"}
# Fit peaks found by automatic detection
peak_fit1 <- fitPeaks(peak_index, scale = "chanel")

plot(peak_fit1) +
  ggplot2::labs(title = "Automatic peak detection", 
                x = "Chanel", y = "Count") +
  ggplot2::theme_bw()

# Fit peaks at a given energy (keV)
peak_fit2 <- fitPeaks(spc_clean1, peaks = c(238, 1461, 2614.5), scale = "energy")

plot(peak_fit2) +
  ggplot2::labs(title = "Fixed peak positions (keV)", x = "Energy [keV]", y = "Count") +
  ggplot2::theme_bw()

# Fit peaks at a given chanel
peak_fit3 <- fitPeaks(spc_clean1, peaks = c(86, 493, 876), scale = "chanel")

plot(peak_fit3) +
  ggplot2::labs(title = "Fixed peak positions (chanel)", x = "Energy [keV]", y = "Count") +
  ggplot2::theme_bw()
```

```{r peak-table, echo=FALSE}
knitr::kable(
  peak_fit2[["peaks"]],
  digits = 3,
  col.names = c("Chanel", "Energy [keV]", "Count", "Count rate [1/s]"),
  caption = "Peak positions (fixed energy)."
)

knitr::kable(
  peak_fit3[["peaks"]],
  digits = 3,
  col.names = c("Chanel", "Energy [keV]", "Count", "Count rate [1/s]"),
  caption = "Peak positions (fixed chanels)."
)
```

### Calibrate energy scale
```{r calibrate}
calib_lines <- list(
  Pb = c(86, 238),
  K = c(493, 1461),
  Cs = c(876, 2614.5)
)

tka_scale <- calibrateEnergy(spc_tka, lines = calib_lines)

plot(tka_scale) +
  ggplot2::geom_vline(xintercept = c(238, 1461, 2614.5), linetype = 3) +
  ggplot2::labs(x = "Energy [keV]", y = "Count") +
  ggplot2::theme_bw()
```

## Gamma dose rate estimation
### Build calibration curve
#### Import files
```{r import-calib, fig.width=7, fig.height=5, fig.align="center"}
# Import CNF files for calibration
cnf_cerege <- system.file("extdata/cerege/", package = "gamma")
spc_cerege <- read(cnf_cerege)
spc_cerege

# Plot spectra
plot(spc_cerege, select = NULL) +
  ggplot2::labs(x = "Energy [keV]", y = "Counts") +
  ggplot2::theme_bw()

# Select 'BRIQUE', 'C341', 'C347', 'GOU' and 'PEB' spectra to build the curve
spc_calib <- spc_cerege[c("BRIQUE", "C341", "C347", "GOU", "PEP")]
# Select 'PB' spectra for background measurement
spc_noise <- spc_cerege[["PB"]]
```

#### Background noise measurement
Le spectre pour la mesure de bruit est particulièrement bruité, la recherche automatique de pics ne peut pas aboutir.
On va donc forcer les canaux a utiliser pour la calibration en énergie.

```{r background-noise, fig.width=7, fig.height=5, fig.align="center"}
calib_noise <- list(
  Pb = c(86, 238),
  K = c(492, 1461),
  Cs = c(866, 2614.5)
)

noise_scale <- calibrateEnergy(spc_noise, lines = calib_noise, force = TRUE)

plot(noise_scale) +
  ggplot2::geom_vline(xintercept = c(238, 1461, 2614.5), linetype = 3) +
  ggplot2::labs(x = "Energy [keV]", y = "Count") +
  ggplot2::theme_bw()
```

Une fois la calibration en énergie faite, on peut intégrer le spectre.
```{r integrate-noise}
noise <- integrateSignal(noise_scale)
noise
```

#### Build curve

```{r calibration-curve, fig.width=5, fig.height=5, fig.align="center"}
# Calibrate energy scale
calib_lines <- list(
  Pb = c(86, 238),
  K = c(493, 1461),
  Cs = c(876, 2614.5)
)

calib_scale <- calibrateEnergy(spc_calib, lines = calib_lines)

# Build calibration curve
known_dose <- list(
  BRIQUE = c(1984.64, 34.08),
  C347 = c(1421.38, 25.25),
  C341 = c(849.01, 21.32),
  PEP = c(2535.53, 112.17),
  GOU = c(1573.41, 17.43)
)

calib_curve <- calibrateDose(
  calib_scale,
  dose = known_dose,
  noise = noise
)
calib_curve

# Plot Calibration curve
plot(calib_curve) +
  ggplot2::labs(x = "Signal", y = "Dose rate [µGy/y]") +
  ggplot2::theme_bw()
```

### Dose rate estimation
```{r dose-rate, fig.width=7, fig.height=5, fig.align="center"}
# Calibrate energy scale
cnf_scale <- calibrateEnergy(spc_cnf, lines = calib_lines)

cnf_shift <- new("GammaSpectra", list(raw = spc_cnf, calibrated = cnf_scale))

plot(cnf_shift) +
  ggplot2::geom_vline(xintercept = c(238, 1461, 2614.5), linetype = 3) +
  ggplot2::labs(x = "Energy [keV]", y = "Count") +
  ggplot2::theme_bw()

# Estimate dose rate
dose_rate <- estimateDoseRate(cnf_scale, calib_curve, 
                              noise = list(value = 1190, error = 1))
as(dose_rate, "data.frame")
```

## References
