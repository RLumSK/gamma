---
title: "Manual"
author: "N. Frerebeau"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    fig_caption: yes
    toc: true
header-includes:
   - \usepackage{amsmath}
   - \usepackage{amssymb}
bibliography: bibliography.bib
vignette: >
  %\VignetteIndexEntry{manual}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(gamma)
library(magrittr)
```

## Spectrum inspection
### Import a CNF file
```{r import, fig.width=7, fig.height=5, fig.alipeaks_pgn="center"}
# Import CNF files for calibration
cnf_test <- system.file("extdata/test1.cnf", package = "gamma")
spc <- read(cnf_test)
spc

# Plot spectra
plot(spc, xaxis = "energy", yaxis = "rate") +
  ggplot2::labs(x = "Energy [keV]", y = "Count rate [1/s]") +
  ggplot2::theme_bw()
```

### Estimate and remove background
Algorithme SNIP [@ryan1988; @morhac1997; @morhac2008]

```{r baseline-estimate, fig.width=7, fig.height=5, fig.align="center"}
# Estimate baseline
baseline <- estimateBaseline(spc, method = c("SNIP"))

# Plot spectrum + baseline
plot(spc, baseline) +
  ggplot2::labs(x = "Energy [keV]", y = "Count") +
  ggplot2::theme_bw()
```

```{r baseline-remove, fig.width=7, fig.height=5, fig.align="center"}
# Substract previously estimated baseline
spc_clean1 <- spc - baseline
# Or, you can just remove baseline from spectrum
spc_clean2 <- removeBaseline(spc)

identical(spc_clean1, spc_clean2)

# Plot spectra
plot(spc_clean1) +
  ggplot2::labs(x = "Energy [keV]", y = "Count") +
  ggplot2::theme_bw()
```

### Automatic peak detection
On peut tenter de détecter automatiquement les pics présents dans le spectre.
Un pic est identifié comme tel s'il y a changement de signe de la courbe dans une fenêtre donnée et si la valeur est supérieure a *n* fois le rapport signal sur bruit.

Le vrai problème reside dans le choix de la fenêtre pour la recherche de pics.
Si `span = NULL` la demi-fenêtre de recherche est fixée à 5% du nombre de canaux.

```{r peak-detection, fig.width=7, fig.height=5, fig.align="center", fig.show="hold"}
# Detect peaks
peak_index <- findPeaks(spc_clean1, SNR = 2, span = 20)

plot(peak_index) +
  ggplot2::labs(x = "Energy [keV]", y = "Count") +
  ggplot2::theme_bw()
```

### Peak fitting
Comme le spectre est bruité, il peut y avoir un léger décalage entre la position du pic identifié automatiquement et la valeur attendue. Pour améliorer ça, on ajuste des gaussiennes aux positions souhaitées et on en récupère les paramètres. La position du pic retenue est alors la valeur du spectre la plus proche de la moyenne de la gaussienne correspondante.

On peut ajuster des gaussiennes directement à partir des résultats de l'étape précédente (détection automatique) ou spécifier les positions de départ.

Si les pics sont trop rapprochés ou le signal trop bruité, la première solution peut ne pas aboutir (problème de convergence lors de l'ajustement des gaussiennes). Dans la mesure où on est interessé par seulement trois pics (238, 1461, 2614.5 keV), la seconde approche produit de meilleurs résultats (et réduit le temps de calcul).

Dans tous les cas, mieux vaut vérifier visuellement les résultats après.

```{r peak-fitting, fig.width=7, fig.height=5, fig.align="center", fig.show="hold"}
# Fit peaks found by automatic detection
peak_fit1 <- fitPeaks(peak_index)

plot(peak_fit1) +
  ggplot2::labs(title = "Model from automatic peak detection", x = "Energy [keV]", y = "Count") +
  ggplot2::theme_bw()

# Fit peaks at a given energy (keV)
peak_fit2 <- fitPeaks(spc_clean1, peaks = c(238, 1461, 2614.5))

plot(peak_fit2) +
  ggplot2::labs(title = "Model from fixed peak positions", x = "Energy [keV]", y = "Count") +
  ggplot2::theme_bw()
```

```{r peak-table, echo=FALSE}
knitr::kable(
  peak_fit2[["peaks"]],
  digits = 3,
  col.names = c("Chanel", "Energy [keV]", "Count", "Count rate [1/s]")
)
```

### Adjust for energy shift
```{r adjust}
spc_adjust <- adjust(spc, peaks = c(238, 1461, 2614.5))

spc_shift <- new("GammaSpectra", list(raw = spc, shifted = spc_adjust))

plot(spc_shift) +
  ggplot2::geom_vline(xintercept = c(238, 1461, 2614.5), linetype = 3) +
  ggplot2::labs(x = "Energy [keV]", y = "Count") +
  ggplot2::theme_bw()
```

## Gamma dose rate estimation
### Build calibration curve
#### Import files
```{r import-calib, fig.width=7, fig.height=5, fig.align="center"}
# Import CNF files for calibration
cnf_cerege <- system.file("extdata/cerege/", package = "gamma")
spc_cerege <- read(cnf_cerege)
spc_cerege

# Plot spectra
plot(spc_cerege, select = NULL) +
  ggplot2::labs(x = "Energy [keV]", y = "Counts") +
  ggplot2::theme_bw()

# Select 'BRIQUE', 'C341', 'C347', 'GOU' and 'PEB' spectra to build the curve
spc_calib <- spc_cerege[c("BRIQUE", "C341", "C347", "GOU", "PEP")]
# Select 'PB' spectra for background measurement
spc_noise <- spc_cerege[["PB"]]
```

#### Background noise measurement
Pas fonctionnel du tout.

Par la suite on utilise la valeur de bruit de fond estimée à la main (1190 +/- 1).
```{r background-noise, fig.width=7, fig.height=5, fig.align="center"}
# Plot spectrum
plot(spc_noise) +
  ggplot2::labs(x = "Energy [keV]", y = "Counts") +
  ggplot2::theme_bw()
```

```{r integrate-noise, eval=FALSE, fig.width=7, fig.height=5, fig.align="center"}
# Estimate baseline
noise_baseline <- estimateBaseline(spc_noise, method = "SNIP", LLS = TRUE, m = 20)

# Plot spectrum
plot(spc_noise, noise_baseline) +
  ggplot2::labs(x = "Energy [keV]", y = "Counts") +
  ggplot2::theme_bw()

noise_clean <- spc_noise - noise_baseline
plot(noise_clean)

noise_peaks <- findPeaks(noise_clean, span = 20)
plot(noise_peaks)

noise_fit <- fitPeaks(noise_peaks)
plot(noise_fit)

# Integrate background noise between 200 keV and 2800 keV
noise <- integrateSignal(spc_noise, peaks = c(238, 1461, 2614.5))
noise
```

#### Build curve

```{r calibration-curve, fig.width=5, fig.height=5, fig.align="center"}
# Build calibration curve
known_dose <- list(
  BRIQUE = c(1984.64, 34.08),
  C347 = c(1421.38, 25.25),
  C341 = c(849.01, 21.32),
  PEP = c(2535.53, 112.17),
  GOU = c(1573.41, 17.43)
)

calib_curve <- calibrate(
  spc_calib,
  dose = known_dose,
  noise = list(value = 1190, error = 1)
)
calib_curve

# Plot Calibration curve
plot(calib_curve) +
  ggplot2::labs(x = "Dose rate [µGy/y]", y = "Signal") +
  ggplot2::theme_bw()
```

### Dose rate estimation
```{r dose-rate, fig.width=7, fig.height=5, fig.align="center"}
dose_rate <- estimateDoseRate(spc, calib_curve, 
                              noise = list(value = 1190, error = 1),
                              span = 20)
as(dose_rate, "data.frame")
```

## References
